##关于调度
- 调度应该是最有意思的地方，也是因为对调度的兴趣，才促成了对MOE的开发。   
- 我们常说的裸奔，就是一个while(1)不停的进行if或switch的判断，来实现程序不同分支的执行。当分支越来越复杂，我们就可以把这个分支看做一个独立的任务，只关心任务本身想实现的功能。当任务较多的时候，就要考虑如何让CPU运行这些任务了，这就是调度的方式。   
- 调度的方式有很多，可以让每个任务依次执行（裸奔实际上就是这样处理的），也可以让有事件发生的任务投入执行（事件驱动机制），还可以增加任务优先级。不管哪种方式，调度的方式决定了系统的运行模式，甚至性能。一旦调度方式确定了，就可以围绕这个调度（scheduler）丰富系统的其他模块和接口，逐步形成一个可用的调度系统。   
- 了解TI ZigBee协议栈z-stack的朋友应该知道，它的osal调度是个有趣巧妙的事件驱动调度方式。每个任务都有静态的优先级，当执行到调度部分时，会根据优先级依次检查每个任务是否有事件发生，若无事件则检查下一个次优先级的任务；若有事件发生，则调用该任务的处理部分，同时放弃后续任务的事件检查，再重新检查最高级的任务...这样的好处就是，高优先级的任务总能等到及时的调度，缺点就是所谓的低优先级任务总是被排在最后，对于无明显任务优先级区分的应用场合下，被排在后面的任务只能躺枪等其他任务完成以后再获得执行权，甚至永远得不到响应。   
- contiki的调度方式则不同，虽然没有完全看完contiki的调度部分，但了解到它调度的基本原则（更为复杂的调度方式后续讨论）是一个事件FIFO---哪个任务的事件先发生，就执行哪个任务。这样对于各任务优先级差别不大的应用场合是合理的。   
- 起初MOE叫OSAL-Like，是想抽离z-stack中的osal部分。但在后来发现，个人偏好事件FIFO，加之z-stack声明了些使用限制，于是就修改了调度的方式，并更名为MOE。   
- MOE使用了事件FIFO或事件队列的方式，先发生事件的任务先处理。同时也提供了插队的机制来确保一些高优先级的事件，这样能提高一定实时性。如果想更进一步提高实时性，可以考虑在任务过程中调度其他任务的方式（参考contiki），等考虑清楚之后再添加。   


##关于事件驱动
- 相信事件驱动应该是个很熟悉的概念，单片机系统总是对内外部所发生的事件作出相应的响应---按键按下、定时结束、通讯数据到来....这些在以往的裸奔系统中如果都用查询的方式实现，将会比较低效（至少CPU没有机会休眠），所以为了高效可以采用中断的方式，实际上每个中断都对应着事件。在事件驱动的系统中，每个任务是否得到执行，基本上是取决于是否有相关的事件发生，这样任务其实挺像中断处理程序的。但不同的是，每个任务可以响应各种不同的事件。这里的事件类似于一种软件中断，它不会像硬件中断那样，在发生的那一刻进着手准备响应的中断处理，而是在产生事件的任务（或中断）运行结束之后，程序运行至调度处理部分之后，再根据事件所属的任务进行任务调度，在任务内部，会根据不同的事件作出不同的响应。
- 或许我将之前的调度和这里的事件驱动分开描述并不合适，因为这两者关系非常紧密。正如之前所说，MOE初期是类osal的系统，后来更换了调度方式，发现事件的产生和处理也必须得相应更改。
- OSAL在编译时为每个任务申请了一个2字节的变量用于保存改任务所发生的事件，因为每个任务仅有这一个16bit的变量保存事件，为了应付同一任务有多种多个事件的情况，osal通过事件变量中的每一位来表示一个事件，即一个2字节的事件变量可以同时保存16种事件---对应位为0表示该事件未发生，对应位为1表示该事件发生。说到这要注意两个问题：第一个问题就是只能有16个事件类别，不能每个按键或SPI、uart、i2c都设置个事件，16个事件明显不够用。这时可以进行归类，比如上述事件都可以归于系统事件，而在产生系统事件的同时产生一个消息用于标记具体是哪个事件，通过这个方法就可以扩展事件的数量。第二个问题就是对于同一个任务同一个事件的多次发生，比如两个按键同时按下，产生了系统事件，同时产生两个消息，但任务的2字节事件变量只有一位来标记这两个事件。为了解决这个问题，在处理消息的时候就需要做额外工作，当搜索到一个消息的之后，要继续搜索是否还有消息，如果有就继续产生改任务的系统事件，以便该任务能有机会再次被调度并处理下一个消息。
- Contiki采用的是事件队列的方式，同一个任务的同一个事件或不同事件都可以依次记录上事件队列上，只要队列空间足够，每个事件都会得到处理。对于事件类型的数量，完全取决于记录类型的变量size，如果是一个字节就可以枚举256个事件类别。
- 正如前述，调度和事件的方式是紧密相关的，MOE采用了事件队列的方式，作出了两方面的修改：1、事件可以插队到第一个，即刚产生的事件可以在其他已产生的事件之前进行处理；2、可自动扩展事件队列长度，采用队列（一般数组形式实现）的一个缺点是队列长度固定，如果突发的事件群过多，而系统又没有来得及消化这些事件，那事件队列将累积至满，造成后续事件的丢失。而另一种数据结构可以有效解决长度的问题----链表。如果事件通过链表的方式来记录，在RAM资源充足的情况下可以不断扩展长度，且在无事件的时候释放多余的RAM，事件插队操作在链表上也更容易实现。但链表有个缺点，生产或释放节点时有一定的开销（malloc & free），同时使用链表所产生的额外RAM消耗也不可小觑，举例来说，如果一个事件产生，必要的信息为事件类别和所说任务，一个2个字节，而为了这两个字节，假设在32位的MCU上，链表节点需要额外4个字节记录下一个节点的地址，malloc节点的时候还需要head信息假设大约8个字节，在假设malloc以8字节为块分配HEAP，那记录一个事件就需要((4+2)%8+1)*8+8 = 16个字节，有效数据占比2/16=12.5%，所以用链表也很消耗RAM。MOE为了解决这个问题，将数组循环队列和链表结合起来，例如先生成一个长度为10的队列，当队列满的时候，再动态分配一个长度为10的队列，并接到之前的队列上去，通过链表的方式将两个队列关联起来，当事件消耗到一定数量，且额外增加的队列不在需要时，在释放该队列，这样就可以解决数组队列长度受限的问题，同时解决的链表有效数据低、频繁申请&释放的开销。
- 对于事件还有一个方面需要考虑，就是事件的定义。MOE可以定义256个事件类别，系统已经定义了一些如定时器事件、消息事件、测试事件等等事件类别，但对于不同的任务可能会需要定义新的事件类别，同时这个事件类别很可能会别其他任务所使用（任务间的通讯），所以需要考虑清楚采用何种方式定义事件。这里还要提出一点，就是MOE采用的模块化编程，有一个基本原则就是:“完成、并通过测试软件模块，不得进行任何修改，除非功能有误”。更多关于模块化的思路后续再记录，这里需要考虑一个好的方法，既可以让所有模块（内核和应用）知道事件类型定义，又不需要修改模块的代码（.C和.H）。这个问题留给我慢慢考虑吧


## 关于定时器
- 完成调度和事件部分之后，基本的core就完成了，剩下的就是围绕这个core进行重要模块的添加。其中一个很重要的模块就是软件定时器模块，因为不仅仅外部模块需要计时功能，core也可能需要利用时间信息完成一些工作。
- 软件定时器的基本原理: 记录当前系统ms时钟，设定定时ms数，然后回到任务调度之前（因为任务是在有事件发生后才会被调度的，所以对计时结束的检查是放在调度之外进行轮询的），检查当“前系统ms时钟”与“之前记录的ms时钟”的差值是否大于设定的ms数，即可知道定时器是否计时结束，多个计时器通过链表连维护，当计时次数为0时，将会把该计时器节点从链表上删除。当计时结束后，将会产生事先设定的事件，此刻对应任务就可以做响应处理。例如任务中需要周期控制LED的亮灭，则该任务可以设置一个针对自己的周期定时器，设定事件为“周期定时事件”，然后把需要周期处理的LED操作放到对改事件的处理部分中即可。
- 在回到模块化设计方向，该软件定时器几乎全靠软件实现，唯一需要的硬件支持就是“获取系统ms时钟的函数”，该函数会根据不同的硬件所有不同，为了能兼容不同的MCU和硬件时钟获取方案，采用了函数注册的方式，将外部的“获取系统ms时钟的函数”注册到core的timer中即可。定时的精度基本取决于“获取系统ms时钟的函数”的精度。

## 关于任务中的硬件操作
- MOE十分注重模块化，每个任务也在此原则下进行设计，目的是为了通过几个既有任务的组合，快速实现新功能新产品的开发。

## 关于外部函数
- 这里的外部函数是指内核需要的，但对不同的平台有变化的函数，比如系统ms时钟函数，每个平台的实现方式不一样，但对于内核而言，它只需要改函数返回ms时钟即可。加上有模块化的要求，内核中改函数不能随意更改。这样有几种方法解决：   

1. 统一函数名称，比如在内核中调用的函数名为MOE_Core_Sys_Tm(),那外部就必须用MOE_Core_Sys_Tm()函数名实现该函数。有点事简单直接。缺点是外部的函数也可能属于其他模块，函数名不适合更改等等。
2. 动态注册的方式，定义一个static的函数指针变量，用于保存需要调用的函数的指针，这样可以动态保存函数指针，即使封装成库也没有问题，缺点是需要RAM记录函数指针，如果改指针的值意外被修改，调用时会发生意外。
3. 静态函数指针的方式，在rom中定义函数指针并在初始化的时候赋值，这样不消耗宝贵的ram，也不易出错。

##关于任务注册
完成任务的实现后，需要建立任务与内核的关联，就是要让内核知道如何找到任务并在以后调度它
